<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因">
<meta name="keywords" content="ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6 Proxy">
<meta property="og:url" content="http://yoursite.com/2019/06/17/proxy/index.html">
<meta property="og:site_name" content="露露的笔记">
<meta property="og:description" content="概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-06-17T08:02:21.241Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6 Proxy">
<meta name="twitter:description" content="概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/06/17/proxy/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ES6 Proxy | 露露的笔记</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">露露的笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content="lulu">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="露露的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ES6 Proxy

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-17 13:56:52 / 修改时间：16:02:21" itemprop="dateCreated datePublished" datetime="2019-06-17T13:56:52+08:00">2019-06-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。<br>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="keyword">function</span> (target, key, receiver) &#123;</span><br><span class="line">    console.log(`getting <span class="variable">$&#123;key&#125;</span>!`);</span><br><span class="line">    <span class="built_in">return</span> Reflect.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span> (target, key, value, receiver) &#123;</span><br><span class="line">    console.log(`setting <span class="variable">$&#123;key&#125;</span>!`);</span><br><span class="line">    <span class="built_in">return</span> Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.count = 1</span><br><span class="line">//  setting count!</span><br><span class="line">++obj.count</span><br><span class="line">//  getting count!</span><br><span class="line">//  setting count!</span><br><span class="line">//  2</span><br></pre></td></tr></table></figure>

<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。<br>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(target, handler);</span><br></pre></td></tr></table></figure>

<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, property) &#123;</span><br><span class="line">    <span class="built_in">return</span> 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time // 35</span><br><span class="line">proxy.name // 35</span><br><span class="line">proxy.title // 35</span><br></pre></td></tr></table></figure>

<p>上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。<br>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。<br>如果handler没有设置任何拦截，那就等同于直接通向原对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;&#125;;</span><br><span class="line">var handler = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a // <span class="string">"b"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。</p>
<p>一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123; proxy: new Proxy(target, handler) &#125;;</span><br></pre></td></tr></table></figure>

<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, property) &#123;</span><br><span class="line">    <span class="built_in">return</span> 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = Object.create(proxy);</span><br><span class="line">obj.time // 35</span><br></pre></td></tr></table></figure>

<p>上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。<br>同一个拦截器函数，可以设置拦截多个操作。<br>同一个拦截器函数，可以设置拦截多个操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> Object.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'Hello, '</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: <span class="keyword">function</span>(target, thisBinding, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> args[0];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: <span class="keyword">function</span>(target, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;value: args[1]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fproxy = new Proxy(<span class="keyword">function</span>(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(1, 2) // 1</span><br><span class="line">new fproxy(1, 2) // &#123;value: 2&#125;</span><br><span class="line">fproxy.prototype === Object.prototype // <span class="literal">true</span></span><br><span class="line">fproxy.foo === <span class="string">"Hello, foo"</span> // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。<br>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a><strong>Proxy 实例的方法</strong></h2><p>下面是上面这些拦截方法的详细介绍</p>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a><strong>get()</strong></h2><p>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>
<p>get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxy = new Proxy(person, &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="built_in">return</span> target[property];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      throw new ReferenceError(<span class="string">"Property \""</span> + property + <span class="string">"\" does not exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name // <span class="string">"张三"</span></span><br><span class="line">proxy.age // 抛出一个错误</span><br></pre></td></tr></table></figure>

<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。<br>get方法可以继承。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> proto = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, propertyKey, receiver) &#123;</span><br><span class="line">    console.log(<span class="string">'GET '</span> + propertyKey);</span><br><span class="line">    <span class="built_in">return</span> target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = Object.create(proto);</span><br><span class="line">obj.foo // <span class="string">"GET foo"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。由于obj里面没有foo是undefined</p>
<h2 id="set"><a href="#set" class="headerlink" title="set()"></a><strong>set()</strong></h2><p>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。<br>假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> validator = &#123;</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(obj, prop, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!Number.isInteger(value)) &#123;</span><br><span class="line">        throw new TypeError(<span class="string">'The age is not an integer'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; 200) &#123;</span><br><span class="line">        throw new RangeError(<span class="string">'The age seems invalid'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对于满足条件的 age 属性以及其他属性，直接保存</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> person = new Proxy(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = 100;</span><br><span class="line"></span><br><span class="line">person.age // 100</span><br><span class="line">person.age = <span class="string">'young'</span> // 报错</span><br><span class="line">person.age = 300 // 报错</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。<br>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const handler = &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'get'</span>);</span><br><span class="line">    <span class="built_in">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span> (target, key, value) &#123;</span><br><span class="line">    invariant(key, <span class="string">'set'</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> invariant (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    throw new Error(`Invalid attempt to <span class="variable">$&#123;action&#125;</span> private <span class="string">"<span class="variable">$&#123;key&#125;</span>"</span> property`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const target = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line">proxy._prop</span><br><span class="line">// Error: Invalid attempt to get private <span class="string">"_prop"</span> property</span><br><span class="line">proxy._prop = <span class="string">'c'</span></span><br><span class="line">// Error: Invalid attempt to <span class="built_in">set</span> private <span class="string">"_prop"</span> property</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<p>下面是set方法第四个参数的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const handler = &#123;</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(&#123;&#125;, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span>;</span><br><span class="line">proxy.foo === proxy // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身，请看下面的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const handler = &#123;</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(&#123;&#125;, handler);</span><br><span class="line">const myObj = &#123;&#125;;</span><br><span class="line">Object.setPrototypeOf(myObj, proxy);</span><br><span class="line"></span><br><span class="line">myObj.foo = <span class="string">'bar'</span>;</span><br><span class="line">myObj.foo === myObj // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，设置myObj.foo属性的值时，myObj并没有foo属性，因此引擎会到myObj的原型链去找foo属性。myObj的原型对象proxy是一个 Proxy 实例，设置它的foo属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象myObj。</p>
<p>注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, <span class="string">'foo'</span>, &#123;</span><br><span class="line">  value: <span class="string">'bar'</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const handler = &#123;</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = <span class="string">'baz'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(obj, handler);</span><br><span class="line">proxy.foo = <span class="string">'baz'</span>;</span><br><span class="line">proxy.foo // <span class="string">"bar"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，obj.foo属性不可写，Proxy 对这个属性的set代理将不会生效。</p>
<p>注意，严格模式下，set代理如果没有返回true，就会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line">const handler = &#123;</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">    // 无论有没有下面这一行，都会报错</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(&#123;&#125;, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span>;</span><br><span class="line">// TypeError: <span class="string">'set'</span> on proxy: <span class="built_in">trap</span> returned falsish <span class="keyword">for</span> property <span class="string">'foo'</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，严格模式下，set代理返回false或者undefined，都会报错。</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a><strong>apply()</strong></h2><p>apply方法拦截函数的调用、call和apply操作。</p>
<p>apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> Reflect.apply(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var target = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line">var handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">p()</span><br><span class="line">// <span class="string">"I am the proxy"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量p是 Proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。<br>下面是另外一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var twice = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> Reflect.apply(...arguments) * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> sum (left, right) &#123;</span><br><span class="line">  <span class="built_in">return</span> left + right;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy = new Proxy(sum, twice);</span><br><span class="line">proxy(1, 2) // 6</span><br><span class="line">proxy.call(null, 5, 6) // 22</span><br><span class="line">proxy.apply(null, [7, 8]) // 30</span><br></pre></td></tr></table></figure>

<p>上面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。<br>另外，直接调用Reflect.apply方法，也会被拦截。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reflect.apply(proxy, null, [9, 10]) // 38</span><br></pre></td></tr></table></figure>

<h2 id="has"><a href="#has" class="headerlink" title="has()"></a><strong>has()</strong></h2><p>has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。<br>has方法可以接受两个参数，分别是目标对象、需查询的属性名。<br>下面的例子使用has方法隐藏某些属性，不被in运算符发现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123; _prop: <span class="string">'foo'</span>, prop: <span class="string">'foo'</span> &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy // <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has就会返回false，从而不会被in运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时has拦截会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 10 &#125;;</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line">var p = new Proxy(obj, &#123;</span><br><span class="line">  has: <span class="keyword">function</span>(target, prop) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> p // TypeError is thrown</span><br></pre></td></tr></table></figure>

<p>上面代码中，obj对象禁止扩展，结果使用has拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则has方法就不得“隐藏”（即返回false）目标对象的该属性。<br>值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。<br>另外，虽然for…in循环也用到了in运算符，但是has拦截对for…in循环不生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> stu1 = &#123;name: <span class="string">'张三'</span>, score: 59&#125;;</span><br><span class="line"><span class="built_in">let</span> stu2 = &#123;name: <span class="string">'李四'</span>, score: 99&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> handler = &#123;</span><br><span class="line">  has(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'score'</span> &amp;&amp; target[prop] &lt; 60) &#123;</span><br><span class="line">      console.log(`<span class="variable">$&#123;target.name&#125;</span> 不及格`);</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> oproxy1 = new Proxy(stu1, handler);</span><br><span class="line"><span class="built_in">let</span> oproxy2 = new Proxy(stu2, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> oproxy1</span><br><span class="line">// 张三 不及格</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> oproxy2</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line">  console.log(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line">// 张三</span><br><span class="line">// 59</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line">  console.log(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line">// 李四</span><br><span class="line">// 99</span><br></pre></td></tr></table></figure>

<p>上面代码中，has拦截只对in运算符生效，对for…in循环不生效，导致不符合要求的属性没有被for…in循环所排除。</p>
<h2 id="construct"><a href="#construct" class="headerlink" title="construct()"></a><strong>construct()</strong></h2><p>construct方法用于拦截new命令，下面是拦截对象的写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    <span class="built_in">return</span> new target(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>construct方法可以接受三个参数。</p>
<p>target：目标对象<br>args：构造函数的参数对象<br>newTarget：创造实例对象时，new命令作用的构造函数（下面例子的p）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(<span class="function"><span class="title">function</span></span> () &#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="keyword">function</span>(target, args) &#123;</span><br><span class="line">    console.log(<span class="string">'called: '</span> + args.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="built_in">return</span> &#123; value: args[0] * 10 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(new p(1)).value</span><br><span class="line">// <span class="string">"called: 1"</span></span><br><span class="line">// 10</span><br></pre></td></tr></table></figure>

<p>construct方法返回的必须是一个对象，否则会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(<span class="function"><span class="title">function</span></span>() &#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="keyword">function</span>(target, argumentsList) &#123;</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p() // 报错</span><br><span class="line">// Uncaught TypeError: <span class="string">'construct'</span> on proxy: <span class="built_in">trap</span> returned non-object (<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a><strong>deleteProperty()</strong></h2><p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'delete'</span>);</span><br><span class="line">    delete target[key];</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> invariant (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    throw new Error(`Invalid attempt to <span class="variable">$&#123;action&#125;</span> private <span class="string">"<span class="variable">$&#123;key&#125;</span>"</span> property`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var target = &#123; _prop: <span class="string">'foo'</span> &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">delete proxy._prop</span><br><span class="line">// Error: Invalid attempt to delete private <span class="string">"_prop"</span> property</span><br></pre></td></tr></table></figure>

<p>上面代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。<br>注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错</p>
<h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a><strong>defineProperty()</strong></h2><p>defineProperty方法拦截了Object.defineProperty操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span> // 不会生效</span><br></pre></td></tr></table></figure>

<p>上面代码中，defineProperty方法返回false，导致添加新属性总是无效。<br>注意，如果目标对象不可扩展（non-extensible），则defineProperty不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty方法不得改变这两个设置。</p>
<h2 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a><strong>getOwnPropertyDescriptor()</strong></h2><p>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> Object.getOwnPropertyDescriptor(target, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123; _foo: <span class="string">'bar'</span>, baz: <span class="string">'tar'</span> &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'wat'</span>)</span><br><span class="line">// undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'_foo'</span>)</span><br><span class="line">// undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'baz'</span>)</span><br><span class="line">// &#123; value: <span class="string">'tar'</span>, writable: <span class="literal">true</span>, enumerable: <span class="literal">true</span>, configurable: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，handler.getOwnPropertyDescriptor方法对于第一个字符为下划线的属性名会返回undefined。</p>
<h2 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a><strong>getPrototypeOf()</strong></h2><p>Object.prototype.<strong>proto</strong><br>Object.prototype.isPrototypeOf()<br>Object.getPrototypeOf()<br>Reflect.getPrototypeOf()<br>instanceof</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var proto = &#123;&#125;;</span><br><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  getPrototypeOf(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getPrototypeOf(p) === proto // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，getPrototypeOf方法拦截Object.getPrototypeOf()，返回proto对象。</p>
<p>注意，getPrototypeOf方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（non-extensible）， getPrototypeOf方法必须返回目标对象的原型对象。</p>
<h2 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a><strong>isExtensible()</strong></h2><p>isExtensible方法拦截Object.isExtensible操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    console.log(<span class="string">"called"</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.isExtensible(p)</span><br><span class="line">// <span class="string">"called"</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。</p>
<p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误<br>下面是一个例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.isExtensible(p)</span><br><span class="line">// Uncaught TypeError: <span class="string">'isExtensible'</span> on proxy: <span class="built_in">trap</span> result does not reflect extensibility of proxy target (<span class="built_in">which</span> is <span class="string">'true'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a><strong>ownKeys()</strong></h2><p>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<p>Object.getOwnPropertyNames()<br>Object.getOwnPropertySymbols()<br>Object.keys()<br>for…in循环<br>下面是拦截Object.keys()的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> target = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> handler = &#123;</span><br><span class="line">  ownKeys(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> [<span class="string">'a'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">Object.keys(proxy)</span><br><span class="line">// [ <span class="string">'a'</span> ]</span><br></pre></td></tr></table></figure>

<h2 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a><strong>preventExtensions()</strong></h2><p>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。<br>这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(proxy)</span><br><span class="line">// Uncaught TypeError: <span class="string">'preventExtensions'</span> on proxy: <span class="built_in">trap</span> returned truish but the proxy target is extensible</span><br></pre></td></tr></table></figure>

<p>var proxy = new Proxy({}, {<br>  preventExtensions: function(target) {<br>    return true;<br>  }<br>});</p>
<p>Object.preventExtensions(proxy)<br>// Uncaught TypeError: ‘preventExtensions’ on proxy: trap returned truish but the proxy target is extensible</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    console.log(<span class="string">'called'</span>);</span><br><span class="line">    Object.preventExtensions(target);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(proxy)</span><br><span class="line">// <span class="string">"called"</span></span><br><span class="line">// Proxy &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a><strong>setPrototypeOf()</strong></h2><p>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</p>
<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    throw new Error(<span class="string">'Changing the prototype is forbidden'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var proto = &#123;&#125;;</span><br><span class="line">var target = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">Object.setPrototypeOf(proxy, proto);</span><br><span class="line">// Error: Changing the prototype is forbidden</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要修改target的原型对象，就会报错。</p>
<p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），setPrototypeOf方法不得改变目标对象的原型。</p>
<pre><code class="bash"></code></pre>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ES6/" rel="tag"># ES6</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/17/reflect/" rel="next" title="ES6 Reflect">
                <i class="fa fa-chevron-left"></i> ES6 Reflect
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/17/Interator/" rel="prev" title="Iterator 和 for...of 循环">
                Iterator 和 for...of 循环 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <div class="site-description motion-element" itemprop="description">lulu</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy-实例的方法"><span class="nav-number">2.</span> <span class="nav-text">Proxy 实例的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get"><span class="nav-number">3.</span> <span class="nav-text">get()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set"><span class="nav-number">4.</span> <span class="nav-text">set()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#apply"><span class="nav-number">5.</span> <span class="nav-text">apply()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#has"><span class="nav-number">6.</span> <span class="nav-text">has()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#construct"><span class="nav-number">7.</span> <span class="nav-text">construct()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deleteProperty"><span class="nav-number">8.</span> <span class="nav-text">deleteProperty()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defineProperty"><span class="nav-number">9.</span> <span class="nav-text">defineProperty()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getOwnPropertyDescriptor"><span class="nav-number">10.</span> <span class="nav-text">getOwnPropertyDescriptor()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getPrototypeOf"><span class="nav-number">11.</span> <span class="nav-text">getPrototypeOf()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isExtensible"><span class="nav-number">12.</span> <span class="nav-text">isExtensible()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ownKeys"><span class="nav-number">13.</span> <span class="nav-text">ownKeys()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#preventExtensions"><span class="nav-number">14.</span> <span class="nav-text">preventExtensions()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setPrototypeOf"><span class="nav-number">15.</span> <span class="nav-text">setPrototypeOf()</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
